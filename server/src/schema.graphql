# import UserOrderByInput, BooklikeOrderByInput from './generated/prisma.graphql'

type Book {
  "Generated by json-server"
  id: ID!
  "ISBN Number"
  isbn: String!
  "Books title"
  title: String!
  "Optional Subtitle"
  subtitle: String
  "Who wrote the book"
  author: String!
  "Publisher if known"
  publisher: Publisher
  "where the local book cover is stored"
  imageUrl: String
  "How many pages if known"
  pages: Int
  "What the book is about"
  description: String
  "who likes the book"
  likedBy: [User]
}
# [] means it returns a list of the object type in this case Book
type Publisher {
  id: ID!
  name: String!
  books: [Book]
}
# The "Query" type is the root of all GraphQL queries.
# (x: yyy) are the parameters passed into the function
type Query {
  users(query: String, first: Int, skip: Int, after: String, orderBy: UserOrderByInput): [User!]!
  getCurrentUser: User!
  books: [Book]!
  book(id: ID!): Book!
  publisher(id: ID!): Publisher
  publishers: [Publisher]
  booklikes(query: String, first: Int, skip: Int, after: String, orderBy: UserOrderByInput): [Booklike!]!
}
# Mutations provide the CRUD operations in the interface
type Mutation {
  addBook(data: CreateBookInput): Book
  deleteBook(id: ID!): DeletePayload
  updateBook(data: UpdateBookInput): Book
  createUser(data: CreateUserInput): AuthPayload!
  login(email: String!, password: String!): AuthPayload!
  deleteUser: User!
  updateUser(data: UpdateUserInput!): User!
  likeBook(id: ID!): Booklike
  deleteLike(bookId: ID!):Booklike
}
type AuthPayload {
  token: String!
  user: User!
}
input CreateUserInput {
  name: String!
  email: String!
  password: String!
}
input UpdateUserInput {
  name: String
  email: String
  password: String
}
# json-server does not return the deleted record so return status code
type DeletePayload {
  statuscode: Int
}

type LikePayload {
  statuscode: Int
}
# define a definition for mutation inputs
# publisherId has to match the data source not the schema definition
input CreateBookInput {
  isbn: String!
  title: String!
  subtitle: String
  author: String!
  publisherId: ID!
  pages: Int
  description: String
  imageUrl: String
}
# publisherId has to match the data source not the schema definition
input UpdateBookInput {
  id: ID!
  isbn: String
  title: String
  subtitle: String
  author: String
  publisherId: ID
  pages: Int
  description: String
  imageUrl: String
}

type User {
  id: ID!
  name: String!
  email: String
  password: String!
  updatedAt: DateTime!
  createdAt: DateTime!
  likes: [Book!]
}

type Booklike {
  id: ID!
  user: User!
  bookId: String!
}